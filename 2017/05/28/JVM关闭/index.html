<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="杏仁"><title>JVM关闭 · 杏仁的博客</title><meta name="description" content="JVM关闭JVM既可以正常关闭，也可以强行关闭。正常关闭的触发方式有多种，包括：当最后一个“正常（非守护）”线程结束时，或者当调用了System.exit时，或者通过其他特定于平台的方法关闭时（例如发生了sigint信号或键入Ctrl-C）。虽然可以通过这些标准方法来正常关闭JVM，但也可以通过调用"><meta name="keywords" content="Hexo,HTML,CSS,Java,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">杏仁的博客</a></h3><div class="description"><p>Java | Javascript | Web | tools</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Arquivo</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="http://omt5ar039.bkt.clouddn.com/IMG_0009.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>JVM关闭</a></h3></div><div class="post-content"><h3 id="JVM关闭"><a href="#JVM关闭" class="headerlink" title="JVM关闭"></a>JVM关闭</h3><p>JVM既可以正常关闭，也可以强行关闭。正常关闭的触发方式有多种，包括：当最后一个“正常（非守护）”线程结束时，或者当调用了System.exit时，或者通过其他特定于平台的方法关闭时（例如发生了sigint信号或键入Ctrl-C）。<br>虽然可以通过这些标准方法来正常关闭JVM，但也可以通过调用Runtime.halt或者操作系统中的“杀死”JVM进程（例如发送sigkill）来强行关闭JVM。</p>
<h4 id="关闭钩子"><a href="#关闭钩子" class="headerlink" title="关闭钩子"></a>关闭钩子</h4><p>在正常关闭中，JVM首先调用所有已注册的关闭钩子。关闭钩子是指通过Runtime.addShutdownHook注册的但尚未开始的线程。JVM并不能保证关闭钩子的调用顺序。在关闭应用程序线程时，如果有（守护或非守护）线程仍然在运行，那么这些线程将与关闭线程并发执行。<br>关闭钩子应该是线程安全的：它们在访问共享数据时必须使用同步机制，并且小心地避免发生死锁，这与其他并发代码的要求相同。<br>当被强行关闭时，只是关闭JVM，而不会运行关闭钩子。<br><strong>正常关闭</strong><br>1.程序正常结束<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">&#123;</div><div class="line">	Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread()&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">		&#123;</div><div class="line">			System.out.println(<span class="string">"我在关闭钩子里运行"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	System.out.println(<span class="string">"正常关闭"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.调用System.exit退出程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">&#123;</div><div class="line">	Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread()&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">		&#123;</div><div class="line">			System.out.println(<span class="string">"我在关闭钩子里运行"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	System.out.println(<span class="string">"通过System.exit关闭"</span>);</div><div class="line">	System.exit(<span class="number">0</span>);</div><div class="line">	System.out.println(<span class="string">"-----not printed------"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.通过特定于平台的方法关闭<br>通过如下方法关闭Java进程，其中One为类名<br>➜  ~ ps -ef|grep java | grep One<br>  501  1227   816   0 10:02下午 ??         0:00.17 /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/bin/java -Dfile.encoding=UTF-8 -classpath /Users/<em>*</em>/Documents/workspace/Study/bin One<br>➜  ~ kill 1227<br>➜  ~ </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">&#123;</div><div class="line">	Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread()&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">		&#123;</div><div class="line">			System.out.println(<span class="string">"我在关闭钩子里运行"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	</div><div class="line">	<span class="comment">//死循环，通过特定于平台的方法关闭</span></div><div class="line">	<span class="keyword">boolean</span> b = <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">while</span>(b)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Thread.sleep(<span class="number">10</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	System.out.println(<span class="string">"-----not printed------"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：<br><code>我在关闭钩子里运行</code></p>
<p><strong>非正常关闭</strong><br>若将上面的kill 1227改成kill -9 1227<br>则不会运行关闭钩子，也就不会输出“我在关闭钩子里运行”。</p>
<h4 id="守护线程（Daemon-Thread）"><a href="#守护线程（Daemon-Thread）" class="headerlink" title="守护线程（Daemon Thread）"></a>守护线程（Daemon Thread）</h4><p>线程可分为两种：普通线程和守护线程。在JVM启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程（例如垃圾回收器以及其他执行辅助工作的线程）。当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。<br>普通线程与守护线程之间的差异<strong>仅在于</strong>当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出。当JVM停止时，所有仍然存在的守护线程都将被抛弃——既不会执行finally代码块，也不会执行回卷栈，而JVM只是直接退出。</p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p><strong>Java中的main线程是不是最后一个退出的线程？</strong><br>在main函数里启动一个新线程，新线程跑一个死循环，避免其退出。然后看Eclipse里线程状态，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread [Thread-0] (Running)	</div><div class="line">Thread [DestroyJavaVM] (Running)</div></pre></td></tr></table></figure></p>
<p>若main线程里也跑一个死循环，Eclipse里线程状态如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread [main] (Running)	</div><div class="line">Thread [Thread-0] (Running)</div></pre></td></tr></table></figure></p>
<p>关于DestroyJavaVM线程，参考<a href="https://yq.aliyun.com/articles/25562" target="_blank" rel="external">JVM 内部运行线程介绍</a>一文。<br>执行main()的线程在main执行完后调用JNI中的jni_DestroyJavaVM()方法唤起DestroyJavaVM线程。   JVM在Jboss服务器启动之后，就会唤起DestroyJavaVM线程，处于等待状态，等待其它线程（java线程和native线程）退出时通知它卸载JVM。线程退出时，都会判断自己当前是否是整个JVM中最后一个非deamon线程，如果是，则通知DestroyJavaVM线程卸载JVM。<br>所以：</p>
<ol>
<li>JVM会在所有的非守护线程（用户线程）执行完毕后退出；</li>
<li>main线程是用户线程；</li>
<li>仅有main线程一个用户线程执行完毕，不能决定JVM是否退出，也即是说main线程并不一定是最后一个退出的线程。</li>
</ol>
<p><strong>为啥说JVM关闭，而不是应用程序关闭，一个进程退出意味着JVM退出？</strong><br>一个JVM运行时只能容忍一个“包含main方法的JAVA类“。</p>
<p>一台机器（操作系统）能启动多个JVM进程，各个JVM进程有独自的数据空间和代码空间，互不影响，并且每调用java命令之后（执行启动类的main函数），就是启动一个JVM实例。</p>
<p>只要你内存够大，配置足够高，可以启动多个JVM，甚至是不同厂商、不同版本的JVM。</p>
<p>在执行一个所谓的java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程，而不是我们写的一个个的class文件。这个叫做虚拟机的进程处理一些底层的操作，比如内存的分配和释放等等。我们编写的class文件只是虚拟机进程执行时需要的“原料”。这些“原料”在运行时被加载到虚拟机中，被虚拟机解释执行，以控制虚拟机实现我们java代码中所定义的一些相对高层的操作，比如创建一个文件等，可以将class文件中的信息看做对虚拟机的控制信息，也就是一种虚拟指令。</p>
<p><strong>参考</strong><br>《Java并发编程实战》<br><a href="http://blog.csdn.net/anhuidelinger/article/details/10414829" target="_blank" rel="external">http://blog.csdn.net/anhuidelinger/article/details/10414829</a><br><a href="http://blog.csdn.net/zhangjg_blog/article/details/20380971" target="_blank" rel="external">http://blog.csdn.net/zhangjg_blog/article/details/20380971</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-05-28</span><i class="fa fa-tag"></i><a class="tag" href="/categories/Java/" title="Java">Java </a><a class="tag" href="/tags/java/" title="java">java </a><a class="tag" href="/tags/Thread/" title="Thread">Thread </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://zhuzhucs.com/2017/05/28/JVM关闭/,杏仁的博客,JVM关闭,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/05/29/设计模式入门_创建型模式/" title="设计模式入门_创建型模式">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2017/05/28/Java语法糖——泛型与类型擦除/" title="Java语法糖——泛型与类型擦除">Próximo post</a></li></ul></div><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.7/dist/Valine.min.js?v=undefined"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'kPrvoe1sT8i8q0ziB1KqWlCt-gzGzoHsz',
  app_key:'a3xppHjKmC3F1hx16o0pqlfV',
  placeholder:'',
  path: window.location.pathname,
  avatar:'mm'
})</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>