<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>AbstractQueuedSynchronizer源码理解 · 杏仁的博客</title><meta name="description" content="Java版本：java version “1.8.0_131”AbstractQueuedSynchronizer提供了一个FIFO队列，可以看做是一个可以用来实现锁以及其他需要同步功能的框架。这里简称该类为AQS。AQS的使用依靠继承来完成，子类通过继承自AQS并实现所需的方法来管理同步状态。ja"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">杏仁的博客</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/Ben_wenbin"><i class="fa fa-twitter"></i></a></li><li><a href="http://instagram.com/hwbinbenben"><i class="fa fa-instagram"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/ben0036"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/e71df8021446fe9759a9928b1dd5c28d?s=180&amp;r=G&amp;d="></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>AbstractQueuedSynchronizer源码理解</a></h3></div><div class="post-content"><p>Java版本：java version “1.8.0_131”<br>AbstractQueuedSynchronizer提供了一个FIFO队列，可以看做是一个可以用来实现锁以及其他需要同步功能的框架。这里简称该类为AQS。AQS的使用依靠继承来完成，子类通过继承自AQS并实现所需的方法来管理同步状态。<br>java.util.concurrent中的许多可阻塞的类，例如ReentrantLock、Semaphore、ReentrantRead-WriteLock、CountDownLatch、SynchronousQueue和FutureTask等，都是基于AQS构建的。</p>
<h3 id="AQS的两种功能"><a href="#AQS的两种功能" class="headerlink" title="AQS的两种功能"></a>AQS的两种功能</h3><p>AQS的功能可以分为两种：独占和共享。<br>对于独占功能，例如如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</div><div class="line">	 ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">    		<span class="comment">// do something...</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个很好理解，通过ReentrantLock来保证在lock.lock()之后的代码在同一时刻只能有一个线程来执行，其余的线程将会被阻塞，直到该线程执行了lock.unlock()。这就是一个独占锁的功能。<br>对于共享功能，例如如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</div><div class="line">	  ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line">    lock.readLock().lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">    		<span class="comment">// do something...</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.readLock().unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码中的lock是ReentrantReadWriteLock类的实例，而lock.readLock()为获取其中的读锁，即共享锁，使用方式并无差别，但和独占锁是有区别的：<br>    •    读锁与读锁可以共享<br>    •    读锁与写锁不可以共享（排他）<br>    •    写锁与写锁不可以共享（排他）</p>
<h3 id="AQS独占锁的内部实现"><a href="#AQS独占锁的内部实现" class="headerlink" title="AQS独占锁的内部实现"></a>AQS独占锁的内部实现</h3><p>AQS内部维护着一个FIFO的队列，该队列就是用来实现线程的并发访问控制。队列中的元素是一个Node类型的节点，Node的主要属性如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">   <span class="comment">/**  指示节点正在等待共享模式的标记*/</span></div><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</div><div class="line">   <span class="comment">/** 指示节点正在等待独占模式的标记 */</span></div><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">   <span class="comment">/** waitStatus值指示线程已取消 */</span></div><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</div><div class="line">   <span class="comment">/** waitStatus值表示当前节点的后继节点包含的线程需要开启，也就是unpark； */</span></div><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</div><div class="line">   <span class="comment">/** waitStatus值表示线程正在等待状态，也就是在condition队列中 */</span></div><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * waitStatus值指示下一个acquireShared应无条件地传播</div><div class="line">    */</div><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 状态字段，仅取值：</div><div class="line">    * SIGNAL:  	 该节点的后继者（或将很快）被阻止（通过park），所以当前节点在释放或取消时必须取消其后继。 </div><div class="line">    * 				 为了避免竞争，获取方法必须首先指示它们需要一个信号，然后重试原子获取，然后在失败时阻塞。</div><div class="line">    * CANCELLED:	 该节点由于超时或中断而被取消。 节点永远不会离开这个状态。 </div><div class="line">    * 				 特别地，具有被取消节点的线程再也不会被阻塞。</div><div class="line">    * CONDITION:	 此节点当前处于条件队列。 </div><div class="line">    * PROPAGATE:    releaseShared应该传播到其他节点。仅在共享模式下使用（仅适用于头节点），</div><div class="line">    * 				 以确保传播继续，即使其他操作已经干预。           </div><div class="line">    * 0:			 以上都不是</div><div class="line">    *</div><div class="line">    * 这些值以数字排列以简化使用。 非负值意味着节点不需要信号。 所以，大多数代码不需要检查特定的值，只是为了符号。</div><div class="line">    * </div><div class="line">    * 对于正常同步节点，该字段被初始化为0，对于条件节点，被初始化为CONDITION。 </div><div class="line">    * 它使用CAS（或可能的话，无条件的volatile写入）进行修改。</div><div class="line">    */</div><div class="line">   <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</div><div class="line">   <span class="keyword">volatile</span> Node prev;</div><div class="line">   <span class="keyword">volatile</span> Node next;</div><div class="line">   <span class="comment">//启动该节点的线程。 在构造函数中初始化，使用后无效。</span></div><div class="line">   <span class="keyword">volatile</span> Thread thread;</div><div class="line">   Node nextWaiter;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Returns true if node is waiting in shared mode.</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> nextWaiter == SHARED;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 返回上一个节点，如果为null，则抛出NullPointerException。 </div><div class="line">    * 当前辈不能为null时使用。 空检查可能会被消除，但是可以帮助虚拟机。</div><div class="line">    *</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</div><div class="line">       Node p = prev;</div><div class="line">       <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">       <span class="keyword">else</span></div><div class="line">           <span class="keyword">return</span> p;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></div><div class="line">       <span class="keyword">this</span>.nextWaiter = mode;</div><div class="line">       <span class="keyword">this</span>.thread = thread;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></div><div class="line">       <span class="keyword">this</span>.waitStatus = waitStatus;</div><div class="line">       <span class="keyword">this</span>.thread = thread;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="AQS的变量"><a href="#AQS的变量" class="headerlink" title="AQS的变量"></a>AQS的变量</h3><p>AQS中有一个state变量，该变量对不同的子类实现具有不同的意义，对ReentrantLock来说，它表示加锁的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 等待队列的头结点，懒惰初始化。 除了初始化，它只能通过方法setHead进行修改。 </div><div class="line"> * 注意：如果头存在，则其waitStatus保证不是CANCELLED。</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 等待队列的尾结点，懒惰初始化。 仅通过方法enq修改以添加新的等待节点。</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The synchronization state.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div></pre></td></tr></table></figure>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>这里要说明一下ReentrantLock中的几个内部类：<br>    •    Sync<br>    •    FairSync<br>    •    NonfairSync<br>对于ReentrantLock，有两种获取锁的模式：公平锁和非公平锁。所以对应有两个内部类，都继承自Sync。而Sync继承自AQS。</p>
<h3 id="ReentrantLock的构造函数"><a href="#ReentrantLock的构造函数" class="headerlink" title="ReentrantLock的构造函数"></a>ReentrantLock的构造函数</h3><p>本文结合ReentrantLock的使用来分析同步器独占锁的原理。<br>由于ReentrantLock是可重入锁，所以持有锁的线程可以多次加锁，经过判断加锁线程就是当前持有锁的线程时（即exclusiveOwnerThread==Thread.currentThread()），即可加锁，每次加锁都会将state的值+1，state等于几，就代表当前持有锁的线程加了几次锁;<br>解锁时每解一次锁就会将state减1，state减到0后，锁就被释放掉，这时其它线程可以加锁；<br>当持有锁的线程释放锁以后，如果是等待队列获取到了加锁权限，则会在等待队列头部取出第一个线程去获取锁，获取锁的线程会被移出队列；</p>
<h3 id="ReentrantLock的构造函数-1"><a href="#ReentrantLock的构造函数-1" class="headerlink" title="ReentrantLock的构造函数"></a>ReentrantLock的构造函数</h3><p>ReentrantLock支持公平锁和非公平锁两种方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</div><div class="line">   sync = <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">   sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//同步对象为非公平的锁</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">           setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">       <span class="keyword">else</span></div><div class="line">           acquire(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> nonfairTryAcquire(acquires);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//同步对象为公平的锁</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">       acquire(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Fair version of tryAcquire.  Don't grant access unless</div><div class="line">    * recursive call or no waiters or is first.</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">       <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">       <span class="keyword">int</span> c = getState();</div><div class="line">       <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">           <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">               compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">               setExclusiveOwnerThread(current);</div><div class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">           <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">           <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">           setState(nextc);</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ReentrantLock的加锁操作"><a href="#ReentrantLock的加锁操作" class="headerlink" title="ReentrantLock的加锁操作"></a>ReentrantLock的加锁操作</h3><p>当初始化一个ReentrantLock时，默认是用的非公平锁策略，所以加锁的时候调用的是NonfairSync的lock函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">   sync.lock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NonfairSync的lock函数如下，若加锁成功，保存当前所有者线程的标识，否则调用acquire函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">      setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">  <span class="keyword">else</span></div><div class="line">      acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>acquire函数在AbstractQueuedSynchronizer类中实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">       acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">       selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法主要工作如下：</p>
<pre><code>1.    尝试获取独占锁；
2.    获取成功则返回，否则执行步骤3;
3.    addWaiter方法将当前线程封装成Node对象，并添加到队列尾部；
4.    自旋获取锁，并判断中断标志位。如果中断标志位为true，执行步骤5，否则返回；
5.    设置线程中断。
</code></pre><p>tryAcquire函数的实现在NonfairSync函数中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> nonfairTryAcquire(acquires);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>nonfairTryAcquire函数的实现在ReentrantLock.Sync内部类中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 执行不公平的tryLock。 tryAcquire是在子类中实现的，但是对于trylock方法都需要不公平的尝试。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">  <span class="keyword">int</span> c = getState();</div><div class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">          setExclusiveOwnerThread(current);</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">      <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">      <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">      setState(nextc);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>addWaiter函数和acquireQueued函数的实现在AbstractQueuedSynchronizer类中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 为当前线程和给定模式创建节点并排队。</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</div><div class="line"> * <span class="doctag">@return</span> the new node</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">   Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">   <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></div><div class="line">   Node pred = tail;</div><div class="line">   <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">       node.prev = pred;</div><div class="line">       <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">           pred.next = node;</div><div class="line">           <span class="keyword">return</span> node;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   enq(node);<span class="comment">//将节点插入队列，如有必要，进行初始化。</span></div><div class="line">   <span class="keyword">return</span> node;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 该方法的功能是循环的尝试获取锁，直到成功为止，最后返回中断标志位。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">       <span class="keyword">for</span> (;;) &#123;</div><div class="line">           <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">           <span class="comment">// 如果前继节点是head，则尝试获取</span></div><div class="line">           <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">               setHead(node);</div><div class="line">               p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">               failed = <span class="keyword">false</span>;</div><div class="line">               <span class="keyword">return</span> interrupted;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 如果p不是head或者获取锁失败，判断是否需要进行park</span></div><div class="line">           <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">               parkAndCheckInterrupt())</div><div class="line">               interrupted = <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (failed)</div><div class="line">           cancelAcquire(node);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有几个问题很重要：<br>    •    什么条件下需要park？<br>    •    为什么要判断中断状态？<br>    •    死循环不会引起CPU使用率飙升？<br>下面分别来分析一下。</p>
<p>shouldParkAfterFailedAcquire函数实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检查并更新无法获取的节点的状态。 如果线程阻塞，则返回true。 </div><div class="line"> * 这是所有采集回路中的主要信号控制。 需要pred == node.prev。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">   <span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line">       <span class="comment">// 如果前一个节点的状态是SIGNAL，则需要park；</span></div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">       <span class="keyword">do</span> &#123;</div><div class="line">           node.prev = pred = pred.prev;</div><div class="line">       &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">       pred.next = node;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">// 其他情况，设置前继节点的状态为SIGNAL。</span></div><div class="line">       compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 可见，只有在前继节点的状态是SIGNAL时，需要park。第二种情况稍后会详细介绍。</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先要知道，acquireQueued方法中获取锁的方式是死循环，判断是否中断是在parkAndCheckInterrupt方法中实现的，看下该方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">   LockSupport.park(<span class="keyword">this</span>);</div><div class="line">   <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>非常简单，阻塞当前线程，然后返回线程的中断状态并复位中断状态。<br><strong>注意</strong>interrupted()方法的作用，该方法是获取线程的中断状态，并复位，也就是说，如果当前线程是中断状态，则第一次调用该方法获取的是true，第二次则是false。而isInterrupted()方法则只是返回线程的中断状态，不执行复位操作。</p>
<p>这里就要介绍一下park方法了。park方法是Unsafe类中的方法，与之对应的是unpark方法。简单来说，当前线程如果执行了park方法，也就是阻塞了当前线程，反之，unpark就是唤醒一个线程。</p>
<p>park与wait的作用类似，但是对中断状态的处理并不相同。如果当前线程不是中断的状态，park与wait的效果是一样的；如果一个线程是中断的状态，这时执行wait方法会报java.lang.IllegalMonitorStateException，而执行park时并不会报异常，而是直接返回。</p>
<p>所以，知道了这一点，就可以知道为什么要进行中断状态的复位了：<br>    •    如果当前线程是非中断状态，则在执行park时被阻塞，这是返回中断状态是false；<br>    •    如果当前线程是中断状态，则park方法不起作用，会立即返回，然后parkAndCheckInterrupt方法会获取中断的状态，也就是true，并复位；<br>    •    再次执行循环的时候，由于在前一步已经把该线程的中断状态进行了复位，则再次调用park方法时会阻塞。<br>所以，这里判断线程中断的状态实际上是为了不让循环一直执行，要让当前线程进入阻塞的状态。想象一下，如果不这样判断，前一个线程在获取锁之后执行了很耗时的操作，那么岂不是要一直执行该死循环？这样就造成了CPU使用率飙升，这是很严重的后果。</p>
<p>在acquireQueued方法的finally语句块中，如果在循环的过程中出现了异常，则执行cancelAcquire方法，用于将该节点标记为取消状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 取消持续的获取尝试。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">   <span class="comment">// Ignore if node doesn't exist</span></div><div class="line">   <span class="keyword">if</span> (node == <span class="keyword">null</span>)</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">	<span class="comment">// 设置该节点不再关联任何线程</span></div><div class="line">   node.thread = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">   <span class="comment">// 跳过取消的前节点</span></div><div class="line">   Node pred = node.prev;</div><div class="line">   <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</div><div class="line">       node.prev = pred = pred.prev;</div><div class="line"></div><div class="line">   Node predNext = pred.next;</div><div class="line"></div><div class="line">   <span class="comment">// 可以使用无条件写而不是CAS。</span></div><div class="line">   <span class="comment">// 在这个原子步骤之后，其他节点可以跳过我们。</span></div><div class="line">   <span class="comment">// 之前，我们没有其他线程的干扰。</span></div><div class="line">   node.waitStatus = Node.CANCELLED;</div><div class="line"></div><div class="line">   <span class="comment">/**1.如果当前节点是tail：</span></div><div class="line">    * 尝试更新tail节点，设置tail为pred；</div><div class="line">    * 更新失败则返回，成功则设置tail的后继节点为null</div><div class="line">    */</div><div class="line">   <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</div><div class="line">       compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">// 如果后继者需要信号，请尝试设置pred的next-link</span></div><div class="line">       <span class="keyword">int</span> ws;</div><div class="line">       <span class="keyword">if</span> (pred != head &amp;&amp;</div><div class="line">           ((ws = pred.waitStatus) == Node.SIGNAL ||</div><div class="line">            (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</div><div class="line">           pred.thread != <span class="keyword">null</span>) &#123;</div><div class="line">           Node next = node.next;</div><div class="line">           <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">               compareAndSetNext(pred, predNext, next);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           unparkSuccessor(node);<span class="comment">//唤醒节点的后继，如果存在。</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       node.next = node; <span class="comment">// help GC</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来的工作可以分为3种情况：<br>    •    当前节点是tail；<br>    •    当前节点不是head的后继节点（即队列的第一个节点，不包括head），也不是tail；<br>    •    当前节点是head的后继节点。<br>我们依次来分析一下：</p>
<h3 id="ReentrantLock的解锁操作"><a href="#ReentrantLock的解锁操作" class="headerlink" title="ReentrantLock的解锁操作"></a>ReentrantLock的解锁操作</h3><p>ReentrantLock的unlock函数如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 尝试释放此锁。</div><div class="line"> * </div><div class="line"> * 如果当前线程是该锁的持有者，则保持计数递减。 如果保持计数现在为零，则锁定被释放。 </div><div class="line"> * 如果当前线程不是该锁的持有者，则抛出&#123;<span class="doctag">@link</span> IllegalMonitorStateException&#125;。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">   sync.release(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该函数调用AbstractQueuedSynchronizer的release函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">       Node h = head;</div><div class="line">       <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">           unparkSuccessor(h);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>tryRelease函数在ReentrantLock.Sync内部类中实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> c = getState() - releases;</div><div class="line">  <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">  <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">      free = <span class="keyword">true</span>;</div><div class="line">      setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line">  setState(c);</div><div class="line">  <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当前线程被释放之后，需要唤醒下一个节点的线程，通过unparkSuccessor方法来实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 唤醒节点的后继，如果存在。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">   <span class="comment">/*</span></div><div class="line">    * 如果状态为负（即，可能需要信号），则试图在预期信号时清除。 如果这样做失败或状态被等待线程改变是OK的。</div><div class="line">    */</div><div class="line">   <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">   <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">       compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">   <span class="comment">/*</span></div><div class="line">    * 断开线程被保存在后台，通常只是下一个节点。 但是，如果取消或显然为空，则从尾部向前移动以找到实际的未取消的后继者。</div><div class="line">    */</div><div class="line">   Node s = node.next;</div><div class="line">   <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">       s = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">           <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">               s = t;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">       LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>参考</strong><br><a href="http://www.jianshu.com/p/fadac70b2b1c" target="_blank" rel="external">深入理解AbstractQueuedSynchronizer</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-05-21</span><i class="fa fa-tag"></i><a href="/categories/Java/" title="Java" class="tag">Java </a><a href="/tags/java/" title="java" class="tag">java </a><a href="/tags/Lock/" title="Lock" class="tag">Lock </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2017/05/21/AbstractQueuedSynchronizer源码理解/,杏仁的博客,AbstractQueuedSynchronizer源码理解,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/05/23/Java任务的取消与关闭/" title="Java任务的取消与关闭" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/05/15/Java锁机制理解/" title="Java锁机制理解" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>