<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="杏仁"><title>ThreadPoolExecutor源码理解 · 杏仁的博客</title><meta name="description" content="Java版本：java version “1.8.0_131”
对ThreadPoolExecutor的理解线程个数当提交一个任务时，若线程数少于corePoolSize，将会创建一个新线程来处理请求，即使有其他工作线程空闲。若线程数多于corePoolSize但少于maximumPoolSize，"><meta name="keywords" content="Hexo,HTML,CSS,Java,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">杏仁的博客</a></h3><div class="description"><p>Java | Javascript | Web | tools</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="http://omt5ar039.bkt.clouddn.com/IMG_0009.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>ThreadPoolExecutor源码理解</a></h3></div><div class="post-content"><p>Java版本：java version “1.8.0_131”</p>
<h3 id="对ThreadPoolExecutor的理解"><a href="#对ThreadPoolExecutor的理解" class="headerlink" title="对ThreadPoolExecutor的理解"></a>对ThreadPoolExecutor的理解</h3><h4 id="线程个数"><a href="#线程个数" class="headerlink" title="线程个数"></a>线程个数</h4><p>当提交一个任务时，若线程数少于corePoolSize，将会创建一个新线程来处理请求，即使有其他工作线程空闲。若线程数多于corePoolSize但少于maximumPoolSize，只有当任务队列满了的情况下才会创建新线程。<br>若corePoolSize和maximumPoolSize被设置为相等，则创建了一个固定大小的线程池。</p>
<h4 id="线程超时"><a href="#线程超时" class="headerlink" title="线程超时"></a>线程超时</h4><p>如果线程池中有超过corePoolSize的线程，如果它们空闲时间大于keepAliveTime，超时的线程将被终止。当池没有被积极使用时，能减少资源消耗，如果线程池变得活跃，新线程会再被创建。<br>将keepAliveTime值设为Long.MAX_VALUE能有效地防止空闲线程在池关闭前结束。<br>只有当线程数超过corePoolSize时，keep-alive策略才生效。但是方法allowCoreThreadTimeOut可以使超时策略在基本线程上生效，只要keepAliveTime非零。</p>
<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>有3种队列：直接移交、有界队列和无界队列。<br>无界队列：当所有corePoolSize线程忙时，任务将会在队列中等待，不会有超过corePoolSize个数的线程被创建（maximumPoolSize参数根本不会起作用）</p>
<h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4><p>当Executor关闭或者线程数量和工作队列都达到最大值时，新提交的任务将会被拒绝。有4种饱和策略：AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy。<br><strong>——–以下是对源码的理解———–</strong></p>
<h3 id="ThreadPoolExecutor的变量"><a href="#ThreadPoolExecutor的变量" class="headerlink" title="ThreadPoolExecutor的变量"></a>ThreadPoolExecutor的变量</h3><p>runState提供主要的生命周期控制：<br>  RUNNING:  Accept new tasks and process queued tasks<br>            接收新的任务并且处理排队任务<br>  SHUTDOWN: Don’t accept new tasks, but process queued tasks<br>            不接收新的任务，但是处理排队任务<br>  STOP:     Don’t accept new tasks, don’t process queued tasks,<br>            and interrupt in-progress tasks<br>            不接收新的任务，不处理排队任务，并且中断进行中的任务<br>  TIDYING:  All tasks have terminated, workerCount is zero,<br>            the thread transitioning to state TIDYING<br>            will run the terminated() hook method<br>            所有任务已经终止，工作者数量为0，所有转换到tidying的线程将会运行terminated方法<br>  TERMINATED: terminated() has completed<br>              terminated方法执行完毕<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;<span class="comment">// 前3位表示状态，所有线程数占29位</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;<span class="comment">//线程池容量,线程池中线程的最大数量受此变量限制</span></div><div class="line"><span class="comment">// runState存储在高位中</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</div><div class="line"></div><div class="line"><span class="comment">// 包装和解包装ctl</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</div></pre></td></tr></table></figure></p>
<h3 id="ThreadPoolExecutor的执行任务"><a href="#ThreadPoolExecutor的执行任务" class="headerlink" title="ThreadPoolExecutor的执行任务"></a>ThreadPoolExecutor的执行任务</h3><p>使用ThreadPoolExecutor执行任务的时候，可以使用execute或submit方法，submit方法如下：<br>execute源码如下，execute有调用addWorker方法和reject方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在将来某个时候执行给定的任务。 任务可以在新线程或现有的线程池中的线程执行。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">/*处理分3步</span></div><div class="line">     * 1.如果线程个数少于corePoolSize，新建一个线程，并且command作为它的第一个任务。</div><div class="line">     * 2.如果一个任务可以成功排队，那么我们还需要仔细检查一下是否应该添加一个线程（因为从上次检查后可能有线程挂掉），</div><div class="line">     * 或者是从进入该方法后该池关闭了。 所以我们重新检查状态，如果池停止，则回滚入队，或者如果没有，并且工作线程个数为0，则启动新线程。</div><div class="line">     * 3.如果新的任务不能入队，我们尝试启动一个新线程，如果失败，我们知道池被关闭或者饱和，所以拒绝任务</div><div class="line">     */</div><div class="line">    <span class="comment">//如果线程个数少于corePoolSize，</span></div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</div><div class="line">        reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>reject方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用给定命令的被拒绝的执行处理程序。</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>如果corePoolSize为5，当前线程池中已经有4个工作者线程。当有多个任务同时到达时，workerCountOf(c) &lt; corePoolSize为TRUE，都会调用addWorker函数，但是只有一个线程能够成功，其他线程判断wc大于等于corePoolSize后，直接返回false。然后进行下面的入队操作。</p>
<p>addWorker方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//尝试起一个新的Worker去阻塞队列拿任务并执行任务</span></div><div class="line"><span class="comment">//firstTask:新线程应该首先运行的任务（如果没有，则为null）。 </span></div><div class="line"><span class="comment">//boolean类型的core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小</span></div><div class="line"><span class="comment">//（这里使用一个布尔指示器，而不是一个值，以确保在检查其他池状态后读取新值）。</span></div><div class="line"><span class="comment">//返回值是boolean类型，true表示新任务被接收了，并且执行了。否则是false</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</div><div class="line">    retry:</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// Check if queue empty only if necessary.</span></div><div class="line">        <span class="comment">//非(运行状态)并且非（shutdown状态下任务为空、任务队列非空），就不可以新增线程了</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">            ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</div><div class="line">               ! workQueue.isEmpty()))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//走到这一步说明是运行状态或者shutdown状态下任务为空、任务队列非空</span></div><div class="line">        <span class="comment">//SHUTDOWN: Don't accept new tasks, but process queued tasks</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line">            <span class="comment">//线程数超过最大值时，不允许新增线程</span></div><div class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="comment">//尝试用CAS对c的workerCount字段+1。</span></div><div class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</div><div class="line">                <span class="keyword">break</span> retry;</div><div class="line">            c = ctl.get();  <span class="comment">// 重新读取ctl</span></div><div class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)<span class="comment">// 如果状态改变了，重新循环操作</span></div><div class="line">                <span class="keyword">continue</span> retry;</div><div class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 走到这一步说明cas操作成功了，线程池线程数量+1</span></div><div class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</div><div class="line">    Worker w = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line">        <span class="keyword">final</span> Thread t = w.thread;</div><div class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;<span class="comment">// ThreadFactory构造出的Thread有可能是null，做个判断</span></div><div class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">            mainLock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 当持有所时重新检查.</span></div><div class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</div><div class="line">                <span class="comment">//running状态或者shutdown状态下firstTask为null</span></div><div class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</div><div class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 判断线程是否还活着，也就是说线程已经启动并且还没死掉</span></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line">                    workers.add(w);</div><div class="line">                    <span class="comment">//更新largestPoolSize字段</span></div><div class="line">                    <span class="keyword">int</span> s = workers.size();</div><div class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">                        largestPoolSize = s;</div><div class="line">                    workerAdded = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果任务添加成功，运行任务，改变一下任务成功启动标识</span></div><div class="line">            <span class="keyword">if</span> (workerAdded) &#123;</div><div class="line">                t.start();<span class="comment">// 启动线程，这里的t是Worker中的thread属性，所以相当于就是调用了Worker的run方法</span></div><div class="line">                workerStarted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (! workerStarted)</div><div class="line">            addWorkerFailed(w);<span class="comment">//回滚工作线程的创建</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> workerStarted;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>addWorkerFailed方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//回滚工作线程的创建</span></div><div class="line"><span class="comment">//从workers删除worker，减少worker数量，调用tryTerminate方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</div><div class="line">            workers.remove(w);</div><div class="line">        decrementWorkerCount();</div><div class="line">        tryTerminate();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Worker中的线程start的时候，调用Worker本身run方法，这个run方法调用外部类ThreadPoolExecutor的runWorker方法，直接看runWorker方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Main worker run loop.  Repeatedly gets tasks from queue and</div><div class="line"> * executes them</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</div><div class="line">    Thread wt = Thread.currentThread();</div><div class="line">    Runnable task = w.firstTask;<span class="comment">// 得到Worker中的任务task，也就是用户传入的task</span></div><div class="line">    w.firstTask = <span class="keyword">null</span>;</div><div class="line">    w.unlock(); <span class="comment">// allow interrupts</span></div><div class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//当task不是null</span></div><div class="line">        <span class="comment">//或者task是null时，getTask不为</span></div><div class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</div><div class="line">            w.lock();<span class="comment">// 如果拿到了任务，给自己上锁，表示当前Worker已经要开始执行任务了，已经不是闲置Worker</span></div><div class="line">            <span class="comment">//如果线程池已经处于STOP状态，保证了线程被中断了</span></div><div class="line">            <span class="comment">//否则，中断线程并且再检查一下线程状态</span></div><div class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                 (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) </div><div class="line">                    &amp;&amp;!wt.isInterrupted())<span class="comment">//并且当前线程没有被中断</span></div><div class="line">                wt.interrupt();<span class="comment">//中断当前线程</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//可能抛出异常，导致线程死亡（断开循环，并且completedAbruptly为ture）</span></div><div class="line">                beforeExecute(wt, task);</div><div class="line">                Throwable thrown = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    task.run();<span class="comment">//任何抛出的异常也导致线程死亡。</span></div><div class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    afterExecute(task, thrown);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                task = <span class="keyword">null</span>;</div><div class="line">                w.completedTasks++;</div><div class="line">                w.unlock();<span class="comment">// 执行完任务之后，解锁，Worker变成闲置Worker</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        completedAbruptly = <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        processWorkerExit(w, completedAbruptly);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看一下getTask方法是如何获得任务的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从阻塞队列中获取任务</span></div><div class="line"><span class="comment">//根据当前的配置，阻塞或者限时等待任务，出现以下情况时返回null</span></div><div class="line"><span class="comment">//1.超过maximumPoolSize的workers</span></div><div class="line"><span class="comment">//2.线程池被stop了</span></div><div class="line"><span class="comment">//3.线程池为shutdown，并且任务队列为空</span></div><div class="line"><span class="comment">//4.worker等待任务超时，超时的workers将被终止（allowCoreThreadTimeOut || workerCount &gt; corePoolSize）</span></div><div class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">        <span class="comment">//线程状态大于stop，或者shutdown状态下，队列为空</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">            decrementWorkerCount();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> wc = workerCountOf(c);<span class="comment">// 得到当前线程池Worker个数</span></div><div class="line"></div><div class="line">        <span class="comment">// 标记从队列中取任务时是否设置超时时间，如果为true说明这个worker可能需要回收，</span></div><div class="line">        <span class="comment">//为false的话这个worker会一直存在，并且阻塞当前线程等待阻塞队列中有数据</span></div><div class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line">        <span class="comment">//超过maximumPoolSize的workers或者超时</span></div><div class="line">        <span class="comment">//超过1个worker或者任务队列为空</span></div><div class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</div><div class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 如果需要设置超时时间，使用poll方法，否则使用take方法一直阻塞等待阻塞队列新进数据</span></div><div class="line">            Runnable r = timed ?</div><div class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                workQueue.take();</div><div class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> r;</div><div class="line">            timedOut = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</div><div class="line">            timedOut = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果getTask返回的是null，那说明阻塞队列已经没有任务并且当前调用getTask的Worker需要被回收，那么会调用processWorkerExit方法进行回收：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></div><div class="line">        decrementWorkerCount();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        completedTaskCount += w.completedTasks;</div><div class="line">        workers.remove(w);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tryTerminate();</div><div class="line"></div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</div><div class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;<span class="comment">// Worker是正常结束流程的话</span></div><div class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</div><div class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</div><div class="line">                min = <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</div><div class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// worker数量比线程池基本大小要小</span></div><div class="line">        <span class="comment">// 新开一个Worker代替原先的Worker</span></div><div class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在回收Worker的时候线程池会尝试结束自己的运行，tryTerminate方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//尝试结束线程池</span></div><div class="line"><span class="comment">//如果能够结束线程池，但是工作者线程非0，则中断一个空闲的工作者线程，来传递shutdown信号</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="comment">//线程是running状态或者线程状态大于TIDYING或者线程是shutdown状态并且任务队列非空</span></div><div class="line">        <span class="comment">//以上3种情况直接返回</span></div><div class="line">        <span class="keyword">if</span> (isRunning(c) ||</div><div class="line">            runStateAtLeast(c, TIDYING) ||</div><div class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 走到这一步说明线程池状态为shop，或者shutdown状态并且任务队列为空，可以终止线程池</span></div><div class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></div><div class="line">            interruptIdleWorkers(ONLY_ONE);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 走到这里说明worker已经全部回收了，并且线程池已经不在运行，阻塞队列已经没有任务。可以准备结束线程池了</span></div><div class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">        mainLock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    terminated();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</div><div class="line">                    termination.signalAll();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// else retry on failed CAS</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解释了这么多，对线程池的启动并且执行任务做一个总结：<br>首先，构造线程池的时候，需要一些参数。<br>线程池构造完毕之后，如果用户调用了execute或者submit方法的时候，最后都会使用execute方法执行。<br>execute方法内部分3种情况处理任务：<br>1.如果当前正在执行的Worker数量比corePoolSize(基本大小)要小。直接创建一个新的Worker执行任务，会调用addWorker方法<br>2.如果当前正在执行的Worker数量大于等于corePoolSize(基本大小)。将任务放到阻塞队列里，如果阻塞队列没满并且线程池状态是RUNNING的话，直接丢到阻塞队列，否则执行第3步<br>3.丢到阻塞失败的话，会调用addWorker方法尝试起一个新的Worker去执行任务，如果这个新的Worker创建失败，调用reject方法<br>线程池中的这个基本大小指的是Worker的数量。一个Worker是一个Runnable的实现类，会被当做一个线程进行启动。Worker内部带有一个Runnable属性firstTask，这个firstTask可以为null，为null的话Worker会去阻塞队列拿任务执行，否则会先执行这个任务，执行完毕之后再去阻塞队列继续拿任务执行。<br>所以说如果Worker数量超过了基本大小，那么任务都会在阻塞队列里，当Worker执行完了它的第一个任务之后，就会去阻塞队列里拿其他任务继续执行。<br>Worker在执行的时候会根据一些参数进行调节，比如Worker数量超过了线程池基本大小或者超时时间到了等因素，这个时候Worker会被线程池回收，线程池会尽量保持内部的Worker数量不超过基本大小。<br>另外Worker执行任务的时候调用的是Runnable的run方法，而不是start方法，调用了start方法就相当于另外再起一个线程了。<br>Worker在回收的时候会尝试终止线程池。尝试关闭线程池的时候，会检查是否还有Worker在工作，检查线程池的状态，没问题的话会将状态过度到TIDYING状态，之后调用terminated方法，terminated方法调用完成之后将线程池状态更新到TERMINATED。</p>
<h3 id="ThreadPoolExecutor的关闭"><a href="#ThreadPoolExecutor的关闭" class="headerlink" title="ThreadPoolExecutor的关闭"></a>ThreadPoolExecutor的关闭</h3><p>shutdown方法，关闭线程池，关闭之后阻塞队列里的任务不受影响，会继续被Worker处理，但是新的任务不会被接受：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务。 如果已经关闭，调用没有额外的作用。</div><div class="line"> * 此方法不等待以前提交的任务完成执行。 使用awaitTermination来做到这一点。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        checkShutdownAccess();</div><div class="line">        advanceRunState(SHUTDOWN);</div><div class="line">        interruptIdleWorkers();<span class="comment">//中断空闲workers的线程</span></div><div class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">    tryTerminate();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>shutdownNow函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 尝试停止所有执行的任务，停止等待任务的处理，并返回正在等待执行的任务列表。 </div><div class="line"> * 从此方法返回时，这些任务将从任务队列中排除（删除）。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;Runnable&gt; tasks;</div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        checkShutdownAccess();</div><div class="line">        advanceRunState(STOP);</div><div class="line">        interruptWorkers();<span class="comment">//中断所有workers的线程</span></div><div class="line">        tasks = drainQueue();<span class="comment">//将任务队列排入新列表</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">    tryTerminate();</div><div class="line">    <span class="keyword">return</span> tasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面来看一下interruptIdleWorkers和interruptWorkers函数的具体实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/中断所有workers的线程</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Worker w : workers)</div><div class="line">            w.interruptIfStarted();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="comment">//中断空闲workers的线程</span></div><div class="line"><span class="comment">//onlyOne如果是TRUE，最多中断一个工作线程</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();<span class="comment">// 中断闲置Worker需要加锁，防止并发</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</div><div class="line">            Thread t = w.thread;</div><div class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    t.interrupt();</div><div class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    w.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (onlyOne)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//中断空闲workers的线程</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</div><div class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="4种饱和策略"><a href="#4种饱和策略" class="headerlink" title="4种饱和策略"></a>4种饱和策略</h3><p>CallerPolicy：调用者运行策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在主线程中执行该任务。由于执行任务需要一定的时间，因此主线程至少在一段时间内不能提交任何任务，从而使得工作者线程有时间来处理完正在执行的任务。在这期间，主线程不会调用accept，因此到达的请求将被保存在TCP层的队列中而不是在应用程序的队列中。当服务器过载，这种过载情况会逐渐向外蔓延开来——从线程池到工作队列到应用程序再到TCP层，最终到达客户端，导致服务器在高负载下实现一种平缓的性能降低。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 被拒绝的任务的处理程序直接在&#123;<span class="doctag">@code</span> execute&#125;方法的调用线程中运行被拒绝的任务，</div><div class="line"> * 除非执行程序已经被关闭，在这种情况下这个任务被丢弃。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates a &#123;<span class="doctag">@code</span> CallerRunsPolicy&#125;.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">//执行调用者线程中执行任务，除非执行程序已被关闭，在这种情况下，任务被丢弃。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</div><div class="line">            r.run();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AbortPolicy：终止策略，该策略将抛出未检查异常RejectExecutionException，调用者可以捕获这个异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * A handler for rejected tasks that throws a</div><div class="line"> * &#123;<span class="doctag">@code</span> RejectedExecutionException&#125;.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates an &#123;<span class="doctag">@code</span> AbortPolicy&#125;.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Always throws RejectedExecutionException.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> r the runnable task requested to be executed</div><div class="line">     * <span class="doctag">@param</span> e the executor attempting to execute this task</div><div class="line">     * <span class="doctag">@throws</span> RejectedExecutionException always</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</div><div class="line">                                             <span class="string">" rejected from "</span> +</div><div class="line">                                             e.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DiscardPolicy：当新提交的任务无法保存到队列中时，抛弃策略会悄悄抛弃该任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * A handler for rejected tasks that silently discards the</div><div class="line"> * rejected task.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates a &#123;<span class="doctag">@code</span> DiscardPolicy&#125;.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Does nothing, which has the effect of discarding task r.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> r the runnable task requested to be executed</div><div class="line">     * <span class="doctag">@param</span> e the executor attempting to execute this task</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DiscardOldestPolicy：抛弃最旧的策略会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。如果工作队列是一个优先队列，那么抛弃最旧的策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * A handler for rejected tasks that discards the oldest unhandled</div><div class="line"> * request and then retries &#123;<span class="doctag">@code</span> execute&#125;, unless the executor</div><div class="line"> * is shut down, in which case the task is discarded.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates a &#123;<span class="doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Obtains and ignores the next task that the executor</div><div class="line">     * would otherwise execute, if one is immediately available,</div><div class="line">     * and then retries execution of task r, unless the executor</div><div class="line">     * is shut down, in which case task r is instead discarded.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> r the runnable task requested to be executed</div><div class="line">     * <span class="doctag">@param</span> e the executor attempting to execute this task</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</div><div class="line">            e.getQueue().poll();</div><div class="line">            e.execute(r);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>ThreadPoolExecutor(int corePoolSize,<br>                              int maximumPoolSize,<br>                              long keepAliveTime,<br>                              TimeUnit unit,<br>                              BlockingQueue<runnable> workQueue,<br>                              ThreadFactory threadFactory,<br>                              RejectedExecutionHandler handler)<br>假设现在初始化一个线程池，核心线程数5，最大线程数20，超时时间设置为60秒，阻塞队列容量10。初始化的时候里面没有线程，阻塞队列为空。<br><img src="http://omt5ar039.bkt.clouddn.com/thread%20pool1.png" alt=""></runnable></p>
<p>当有任务到达时，初始化一个线程，执行此任务。<br><img src="http://omt5ar039.bkt.clouddn.com/thread%20pool2.png" alt=""><br>如果第6个任务过来了，把此任务放入到阻塞队列里，等待被执行。<br><img src="http://omt5ar039.bkt.clouddn.com/thread%20pool3.png" alt=""><br>若阻塞队列满了，则在线程池中创建第6个线程。<br><img src="http://omt5ar039.bkt.clouddn.com/thread%20pool5.png" alt=""><br>若线程池中的线程也满了，此时启动handler定义的饱和策略。</p>
<p>若阻塞队列的任务执行完了，并且线程池空闲了一段时间，因为设置了超时时间，从阻塞队列里取数据的时候用的是<strong>带超时时间的poll函数</strong>，而不是take函数。所以，因超时没有取到任务，则会从池中删除工作线程，回收超过核心线程数5的线程。</p>
<h3 id="线程池中的线程状态"><a href="#线程池中的线程状态" class="headerlink" title="线程池中的线程状态"></a>线程池中的线程状态</h3><p>当一个工作者线程被创建后，就不停地尝试从任务队列里取任务，未取到任务的线程处于限期或无限期等待状态，不占用CPU。<br><img src="http://omt5ar039.bkt.clouddn.com/thread_state.png" alt=""><br><strong>新建（New）：</strong>创建后尚未启动的线程处于这种状态。<br><strong>运行（Runnable）：</strong>Runnable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。<br><strong>无限期等待（Waiting）：</strong>处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显示地唤醒。以下方法会让线程陷入无限期的等待状态：<br>1.没有设置Timeout参数的Object.wait()方法。<br>2.没有设置Timeout参数的Thread.join()方法。<br>3.LockSupport.park()方法。<br><strong>限期等待（Timed Waiting）：</strong>处于这种状态的线程也不会被分配CPU执行时间，不过无需等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态。<br>1.Thraed.sleep()方法。<br>2.设置了Timeout参数的Object.wait()方法。<br>3.设置了Timeout参数的Thread.join()方法。<br>4.LockSupport.parkNanos()方法。<br>5.LockSupport.parkUnit()方法。<br><strong>阻塞（blocked）：</strong>线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入阻塞状态。<br><strong>结束（Terminated）：</strong>线程已经结束执行。</p>
<p><strong>参考</strong><br><a href="http://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/" target="_blank" rel="external">http://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/</a><br>《深入理解Java虚拟机》</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-05-05</span><i class="fa fa-tag"></i><a href="/categories/Java/" title="Java" class="tag">Java </a><a href="/tags/java/" title="java" class="tag">java </a><a href="/tags/thread-pool/" title="thread pool" class="tag">thread pool </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://zhuzhucs.com/2017/05/05/ThreadPoolExecutor源码理解/,杏仁的博客,ThreadPoolExecutor源码理解,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/05/07/LinkedBlockingQueue源码理解/" title="LinkedBlockingQueue源码理解" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/04/11/TreeMap源码理解/" title="TreeMap源码理解" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>