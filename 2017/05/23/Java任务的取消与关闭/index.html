<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="杏仁"><title>Java任务的取消与关闭 · 杏仁的博客</title><meta name="description" content="要使任务和线程能安全、快速、可靠地停止下来，并不是一件容易的事。Java没有提供任何机制来安全地终止线程。但它提供了中断，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。
简单的取消任务例子先看一个简单的示例，PrimeGenerator类持续地枚举素数，直到它被取消。cancel方法将设"><meta name="keywords" content="Hexo,HTML,CSS,Java,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">杏仁的博客</a></h3><div class="description"><p>Java | Javascript | Web | tools</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="http://omt5ar039.bkt.clouddn.com/IMG_0009.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Java任务的取消与关闭</a></h3></div><div class="post-content"><p>要使任务和线程能安全、快速、可靠地停止下来，并不是一件容易的事。Java没有提供任何机制来安全地终止线程。但它提供了中断，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。</p>
<h3 id="简单的取消任务例子"><a href="#简单的取消任务例子" class="headerlink" title="简单的取消任务例子"></a>简单的取消任务例子</h3><p>先看一个简单的示例，PrimeGenerator类持续地枚举素数，直到它被取消。cancel方法将设置calcelled标志，并且主循环在搜索下一个素数之前会首先检查这个标志。（为了使这个过程能可靠地工作，标志canceled必须为volatile类型，使得一个线程的修改对另一个线程立即可见）。</p>
<p>使用volatile类型的域来保存取消状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.math.BigInteger;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;BigInteger&gt; primes = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		BigInteger p = BigInteger.ONE;</div><div class="line">		<span class="keyword">while</span>(!cancelled)</div><div class="line">		&#123;</div><div class="line">			p = p.nextProbablePrime();</div><div class="line">			<span class="keyword">synchronized</span>(<span class="keyword">this</span>)</div><div class="line">			&#123;</div><div class="line">				primes.add(p);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"----end----"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		cancelled = <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> List&lt;BigInteger&gt; <span class="title">get</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(primes);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个仅运行一秒钟的素数生成器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aSecondOfPrimes</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></div><div class="line">&#123;</div><div class="line">	PrimeGenerator generator = <span class="keyword">new</span> PrimeGenerator();</div><div class="line">	<span class="keyword">new</span> Thread(generator).start();</div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line">		Thread.sleep(<span class="number">1000</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">finally</span></div><div class="line">	&#123;</div><div class="line">		generator.cancel();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	List&lt;BigInteger&gt; rList = generator.get();</div><div class="line">	<span class="keyword">for</span>(BigInteger r:rList)</div><div class="line">	&#123;</div><div class="line">		System.out.println(r.intValue());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>PrimeGenerator中的取消机制最终会使得搜索素数的任务退出，但在退出的过程中需要花费一定的时间。然而，如果使用这种方法的任务调用了一个阻塞方法，例如BlockingQueue.put，那么可能会产生一个更严重的问题——任务可能永远不会检查取消标志，因此永远不会结束。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下停止当前的工作，并转而执行其他的工作。当线程A中断线程B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作—— 前提是线程B愿意停下来。<br>每个线程都有一个boolean类型的中断状态。当中断线程时，这个线程的中断状态将被设置为true。<br>在Thread中包含了中断线程以及查询线程中断状态的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="comment">//中断目标线程</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">	<span class="comment">//返回目标线程的中断状态</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> isInterrupted &#123; ... &#125;</div><div class="line">	<span class="comment">//清除当前线程的中断状态，并返回之前的值，这也是清除中断状态的唯一方法。</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span>  </span>&#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>阻塞库方法，例如Thread.sleep和Object.wait等，都会检查线程何时中断，并且在发现中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，抛出InterruptedException异常，表示阻塞操作由于中断而提前结束。JVM并不能保证阻塞方法检测到中断的速度，但在实际情况中响应速度还是非常快的。</p>
<p><strong>注意：</strong>调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。<br>对中断操作的正确理解是：它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己（这些时刻也被称为取消点）。<br>有些方法，例如wait、sleep和join等，将严格地处理这种请求，当它们收到中断请求或者在开始执行时发现某个已被设置好的中断状态，将抛出一个异常。</p>
<p>在使用静态的interrupted时应该小心，因为它会清除当前线程的中断状态。如果在调用interrupted时返回了true，那么除非你想屏蔽这个中断，否则必须对它进行处理——可以抛出InterruptedException异常，或者通过再次调用interrupt来恢复中断状态。</p>
<h4 id="对中断的处理"><a href="#对中断的处理" class="headerlink" title="对中断的处理"></a>对中断的处理</h4><p>当在代码中调用了一个将抛出InterruptedException异常的方法时，你自己的方法也就变成了一个阻塞方法，并且必须要处理对中断的响应。对于库代码来说，有两种基本选择：<br><strong>传递InterruptedException</strong> 避开这个异常通常是最明智的策略—— 只需把InterruptedException传递给方法的调用者。传递InterruptedException的方法包括，根本不捕获该异常，或者捕获该异常，然后在执行某种简单的清理工作后，再次抛出这个异常。<br><strong>恢复中断</strong> 有时候不能抛出InterruptedException，例如当代码时Runnable的一部分时，在这些情况下，必须捕获InterruptedException，并通过调用当前线程上的interrupt方法恢复中断状态，这样在调用栈中更高层的代码将看到引发了一个中断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line">&#123;</div><div class="line">	BlockingQueue&lt;Task&gt; queue;</div><div class="line">	...</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">try</span></div><div class="line">		&#123;</div><div class="line">			processTask(queue.take());</div><div class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)</div><div class="line">		&#123;</div><div class="line">			<span class="comment">//恢复被中断的状态</span></div><div class="line">			Thread.currentThread().interrupt();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h4><p>对于一些不支持取消但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法，并在发现中断后重新尝试。在这种情况下，它们应该在本地保存中断状态，并在返回前恢复状态而不是在捕获InterruptedException时回复状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span></span></div><div class="line">&#123;</div><div class="line"> <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line"> <span class="keyword">try</span></div><div class="line"> &#123;</div><div class="line">	 <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">	 &#123;</div><div class="line">		 <span class="keyword">try</span></div><div class="line">		 &#123;</div><div class="line">			 <span class="keyword">return</span> queue.take();</div><div class="line">		 &#125;<span class="keyword">catch</span>(InterruptedException e)</div><div class="line">		 &#123;</div><div class="line">			 interrupted = <span class="keyword">true</span>;</div><div class="line">			 <span class="comment">//重新尝试</span></div><div class="line">		 &#125;</div><div class="line">	 &#125;</div><div class="line"> &#125;<span class="keyword">finally</span></div><div class="line"> &#123;</div><div class="line">	 <span class="keyword">if</span>(interrupted)</div><div class="line">	 &#123;</div><div class="line">		 Thread.currentThread().interrupt();</div><div class="line">	 &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果过早地设置中断状态，就可能引起无限循环，因为大多数可中断的阻塞方法都会在入口处检查中断状态，并且当发现该状态已被设置时会立即抛出InterruptedException。（通常，可中断的方法会在阻塞或进行重要的工作前首先检查中断，从而尽快地响应中断）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span></span></div><div class="line"> &#123;</div><div class="line">	  <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">	  &#123;</div><div class="line">		 <span class="keyword">try</span></div><div class="line">		 &#123;</div><div class="line">			 <span class="comment">//1. 出现中断</span></div><div class="line">			 <span class="comment">//3. 检查中断状态，若已经中断，抛出InterruptedException异常，所以出现死循环</span></div><div class="line">			 <span class="keyword">return</span> queue.take();</div><div class="line">		 &#125;<span class="keyword">catch</span>(InterruptedException e)</div><div class="line">		 &#123;</div><div class="line">			 <span class="comment">//2. 恢复中断</span></div><div class="line">			 Thread.currentThread().interrupt();</div><div class="line">		 &#125;</div><div class="line">	  &#125;</div><div class="line">	 </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h4 id="处理不可中断的阻塞"><a href="#处理不可中断的阻塞" class="headerlink" title="处理不可中断的阻塞"></a>处理不可中断的阻塞</h4><p>并非所有的可阻塞方法或者阻塞机制都能响应中断：如果一个线程由于执行同步的Socker I/O或者等待获得内置锁而阻塞，那么中断请求只能设置线程的中断状态，除此之外没有其他任何作用。<br>对于那些由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求我们必须知道线程阻塞的原因。<br><strong>Java.io包中的同步Socket I/O</strong> 在服务器应用程序中，最常见的阻塞I/O形式就是对套接字进行读取和写入。虽然InputStrem和OutputStrem中的read和write等方法都不会响应中断，但通过关闭底层的套接字，可以使得由于执行read和write等方法而被阻塞的线程抛出一个SocketException。<br><strong>java.io包中的同步I/O</strong> …<br><strong>Selector的异步I/O</strong> …<br><strong>获取某个锁</strong> 如果一个线程由于等待某个内置锁而阻塞，那么将无法响应中断，因为线程认为它肯定会获得锁，所以将不会理会中断请求。但是在Lock类中提供了lockInterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。</p>
<p><strong>参考</strong><br>《Java并发编程实战》</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-05-23</span><i class="fa fa-tag"></i><a href="/categories/Java/" title="Java" class="tag">Java </a><a href="/tags/java/" title="java" class="tag">java </a><a href="/tags/Thread/" title="Thread" class="tag">Thread </a><a href="/tags/Task/" title="Task" class="tag">Task </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2017/05/23/Java任务的取消与关闭/,杏仁的博客,Java任务的取消与关闭,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/05/28/String-StringBuilder和StringBuffer/" title="String StringBuilder和StringBuffer" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/05/15/Java锁机制理解/" title="Java锁机制理解" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>